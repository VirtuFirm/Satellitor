from collections import defaultdict
import requests
from satellitor_backend import model,crops
import cv2
import numpy as np
import ee
import pickle
import os
from datetime import datetime


BASE_DIR = os.path.dirname(os.path.abspath(__file__))




# class_colors in BGR
class_colors = {
    0: (0, 0, 0),  # background
    1: (0, 255, 0), # agriculture
    2: (255, 255, 255),# Barren
    3: (0, 0, 255),  # Urban
    4: (255, 0, 0)    # Water
}


# ============================================================

def yolo_mask(img, model=model):
        """
        Performs object detection and segmentation on an input image using a YOLO model.

        Parameters:
        -----------
        img : numpy.ndarray or str
            The input image to process. Can be a NumPy array (e.g., from OpenCV) or a file path to an image.

        model : callable, optional
            A preloaded YOLO model instance used for inference. The default is a globally defined 'model'.

        Returns:
        --------
        results[0] : ultralytics.engine.results.Results
            The detection results for the image, including:
                - bounding boxes
                - class predictions
                - confidence scores
                - segmentation masks (accessible via results[0].masks)

        --------
        >>> from ultralytics import YOLO
        >>> model = YOLO("yolov8n-seg.pt")
        >>> result = yolo_mask("image.jpg", model=model)
        >>> masks = result.masks
        """
        results = model(img)
        masks = results[0].masks
        return results[0]

# ============================================================

def assign_colors(mask_img):
    """
    Assigns specific colors to pixels in the mask image based on their RGB values.

    Parameters:
        mask_img (np.array): The input mask image.

    Returns:
        np.array: Updated mask image with assigned colors.
    """
    # Reshape image to 2D (flatten pixels)
    height, width, _ = mask_img.shape
    for y in range(height):
        for x in range(width):
            pixel = mask_img[y, x]
            print(f"Pixel at ({x},{y}): {pixel}")

    return mask_img

# ============================================================

def get_mask(img_path,output_path, model=model):
    """
    Applies segmentation masks from a YOLO model to an input image and saves the result.

    Parameters:
    -----------
    img_path : str
        Path to the input image file.

    output_path : str
        Path to save the output image with segmentation masks applied.

    model : callable, optional
        A YOLO segmentation model used for inference. Defaults to a globally defined 'model'.

    Returns:
    --------
    mask_img : numpy.ndarray or None
        The image with segmentation masks applied, or None if the input image could not be read.

    Notes:
    ------
    - The function uses a predefined dictionary `class_colors` to assign colors based on class ID.
    - If the model does not detect any masks, the saved image will remain black.
    - Prints a message when mask processing is completed or if there's an error reading the image.

    Example:
    --------
    >>> get_mask("input.jpg", "masked_output.jpg", model=my_yolo_model)
    """
    img = cv2.imread(img_path)
    if img is None:
        print("Error: Image not found!")
        return

    mask_img = np.zeros_like(img)

    results = model.predict(img)

    for result in results:
        if result.masks is not None:
            masks = result.masks.data.cpu().numpy()
            class_ids = result.boxes.cls.cpu().numpy().astype(int)

            for i, mask in enumerate(masks):
                mask = cv2.resize(mask, (img.shape[1], img.shape[0]))
                mask = (mask > 0.5).astype(np.uint8)
                color = class_colors.get(class_ids[i], (0, 0, 0))
                mask_img[mask == 1] = color

    cv2.imwrite(output_path, mask_img)
    print("Mask processing completed!")
    return mask_img

# ============================================================

def get_Percentage(mask_img,show_in_console):
    """
       Calculates the percentage of each land class (e.g., Agriculture, Urban, etc.)
       present in a segmented mask image based on predefined RGB color values.

       Parameters
       ----------
       mask_img : numpy.ndarray
           The mask image generated by the segmentation model, with each class represented by a specific color.

       show_in_console : bool
           If True, prints the percentage of each detected class to the console.

       Returns
       -------
       class_percentage : dict
           A dictionary containing the percentage (as a float between 0 and 1) of each class:
           'Background', 'Agriculture', 'Barren', 'Forest', 'Urban', and 'Water'.

       Notes
       -----
       - Colors are matched with a tolerance threshold using hardcoded RGB ranges:
           * Background: near black (0, 0, 0)
           * Agriculture: green (0, 255, 0)
           * Barren: white (255, 255, 255)
           * Forest: dark green (0, 127, 0)
           * Urban: blue (0, 0, 255)
           * Water: red (255, 0, 0)

    """
    px = mask_img.reshape(-1, 3)
    class_count = defaultdict(int)

    for pixel in px:
        if pixel[0] < 10 and pixel[1] < 10 and pixel[2] < 10:
            class_count["Background"] += 1
        elif pixel[0] < 10 and pixel[1] > 240 and pixel[2] < 10:
            class_count["Agriculture"] += 1
        elif pixel[0] > 240 and pixel[1] > 240 and pixel[2] > 240:
            class_count["Barren"] += 1
        elif pixel[0] < 10 and pixel[1] < 10 and pixel[2] > 240:
            class_count["Urban"] += 1
        elif pixel[0] > 240 and pixel[1] < 10 and pixel[2] < 10:
            class_count["Water"] += 1

    class_percentage = {"Background":0.0,"Agriculture":0.0,"Barren":0.0,"Urban":0.0,"Water":0.0}


    for class_name, count in class_count.items():
        class_percentage[class_name] = round(count / px.shape[0],3)
        if show_in_console:
            print(f"{class_name}: {round(count / px.shape[0] * 100,1)}%")

    return class_percentage

# ============================================================

def rgb_to_class_index(img_mask, color_map, tolerance=10):
    """
        Converts a color-coded segmentation mask into a class index mask based on a predefined color map.

        Parameters
        ----------
        img_mask : numpy.ndarray
            The RGB image representing class segments using specific colors.

        color_map : dict
            A dictionary where keys are class indices and values are RGB tuples (R, G, B)
            representing the color for that class.

        tolerance : int, optional
            Allowed deviation for color matching, default is 10.

        Returns
        -------
        class_mask : numpy.ndarray
            A 2D array of shape (H, W) where each pixel value corresponds to a class index.

    """
    # Get image dimensions
    h, w, _ = img_mask.shape
    class_mask = np.zeros((h, w), dtype=np.uint8)

    img_mask = img_mask.astype(np.int16)

    for class_idx, (r_ref, g_ref, b_ref) in color_map.items():
        # Define lower and upper bounds
        lower_bound = np.array([max(0, r_ref - tolerance), max(0, g_ref - tolerance), max(0, b_ref - tolerance)])
        upper_bound = np.array([min(255, r_ref + tolerance), min(255, g_ref + tolerance), min(255, b_ref + tolerance)])

        class_range = (
                (img_mask[:, :, 0] >= lower_bound[0]) & (img_mask[:, :, 0] <= upper_bound[0]) &
                (img_mask[:, :, 1] >= lower_bound[1]) & (img_mask[:, :, 1] <= upper_bound[1]) &
                (img_mask[:, :, 2] >= lower_bound[2]) & (img_mask[:, :, 2] <= upper_bound[2])
        )

        class_mask[class_range] = class_idx

    return class_mask


def get_fragmentation(img_mask, class_colors=class_colors):
    """
        Computes the fragmentation index for each land class in a segmentation mask image.

        Fragmentation index is defined as the number of disconnected regions (components)
        for a class. A normalized version is also returned which is (#regions - 1) / area.

        Parameters
        ----------
        img_mask : numpy.ndarray
            The RGB segmentation mask image.

        class_colors : dict
            Dictionary mapping class indices to RGB color values (default is global `class_colors`).

        Returns
        -------
        fragmentation_index : dict
            A dictionary mapping class indices to the number of disconnected components (regions).

        normalized_FI : dict
            A dictionary mapping class indices to normalized fragmentation index values.

        Notes
        -----
        - Class with index 0 (usually background) is ignored in calculation.
        - If a class doesn't appear in the image, both indices will be zero for it.

    """
    class_mask = rgb_to_class_index(img_mask, class_colors)

    fragmentation_index = {}
    normalized_FI = {}

    for class_idx in class_colors.keys():
        # Ignore background
        if class_idx == 0:
            continue

        # Create a binary mask for the current class
        binary_mask = (class_mask == class_idx).astype(np.uint8)

        # -------------------------------------------------------------------------------------

        area = np.sum(binary_mask)

        if area == 0:
            fragmentation_index[class_idx] = 0
            normalized_FI[class_idx] = 0
            continue

        # -------------------------------------------------------------------------------------

        # Find connected components
        num_labels, _ = cv2.connectedComponents(binary_mask)

        # -------------------------------------------------------------------------------------
        normalized_FI[class_idx] = float((num_labels - 1) / area)
        # -------------------------------------------------------------------------------------

        # save FI (subtract 1 because background is counted)
        fragmentation_index[class_idx] = num_labels - 1

    return fragmentation_index,normalized_FI


# ============================================================

def detect_edges(mask_img ,output_path):
    """
       Applies edge detection on a segmentation mask image and saves the result.

       Parameters
       ----------
       mask_img : numpy.ndarray
           The input image (can be grayscale or BGR colored mask).

       output_path : str
           Path to save the output image showing the detected edges.

       Returns
       -------
       edges : numpy.ndarray
           A binary image (single-channel) showing the detected edges using Canny edge detection.

       Notes
       -----
       - If the input image is in color, it will be converted to grayscale first.
       - Applies Gaussian blur before Canny edge detection to reduce noise.
       - Edge detection thresholds are fixed at (50, 150) for Canny.
    """
    if len(mask_img.shape) > 2:
        gray = cv2.cvtColor(mask_img, cv2.COLOR_BGR2GRAY)
    else:
        gray = mask_img

    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)

    cv2.imwrite(output_path, edges)
    return edges


# ============================================================

def get_land_properties(lat,long):
    """
       Retrieves land properties for a given geographic coordinate using remote sensing APIs.

       Parameters
       ----------
       lat : float
           Latitude of the target location.

       long : float
           Longitude of the target location.


       Returns
       -------
       tuple
           A tuple containing:
               - ph_value (float): Estimated average soil pH from 0–100 cm depth. Returns -1 if data is unavailable.
               - temperature (float): Annual average temperature in Celsius from NASA Power API.
               - humidity (float): Annual average relative humidity (%) from NASA Power API.
               - annual_mm (float): Estimated annual precipitation (in mm) from OpenLandMap data.


       Notes
       -----
       - Soil pH values are averaged from depths: 0, 10, 30, 60, 100 cm using the "OpenLandMap/SOL" dataset.
       - Precipitation data is retrieved as the sum of monthly values from "OpenLandMap/CLM".
       - Temperature and humidity data are fetched from NASA POWER API (climatology endpoint).
       - The function prints status updates to the console for tracking.

       """

    print("Getting land points...")
    point = ee.Geometry.Point([long,lat])
    print("Land Points have been retrieved")


    print("Getting land PH...")
    ph_dataset = ee.Image("OpenLandMap/SOL/SOL_PH-H2O_USDA-4C1A2A_M/v02")

    bands=["b0","b10","b30","b60","b100"]
    ph_value=0
    b_num=0
    for band in bands:
        try:
            ph_value += ph_dataset.sample(point, scale=30).first().get(band).getInfo()
            b_num += 1
        except:
            continue
    if b_num == 0:
        ph_value = -1
    else:
        ph_value = ph_value/(b_num*10)
    print("Land PH calculated!")


    print("Getting land Precipitation...")
    d= ee.Image("OpenLandMap/CLM/CLM_PRECIPITATION_SM2RAIN_M/v01")

    monthly_bands = ['jan', 'feb', 'mar', 'apr', 'may', 'jun','jul', 'aug', 'sep', 'oct', 'nov', 'dec']

    annual_precip = d.select(monthly_bands).reduce(ee.Reducer.sum())

    sample = annual_precip.sample(region=point, scale=1000).first()

    annual_mm = sample.get('sum').getInfo()
    print(f"Annual precipitation (mm/year): {annual_mm}")

    nasa_api = f"https://power.larc.nasa.gov/api/temporal/climatology/point?parameters=T2M,RH2M&latitude={lat}&longitude={long}&format=JSON&community=ag"
    climate_data = requests.get(nasa_api).json()


    temperature = climate_data["properties"]["parameter"]["T2M"]["ANN"]
    humidity = climate_data["properties"]["parameter"]["RH2M"]["ANN"]

    print(f"Location: ({lat}, {long})")
    print(f"Soil pH (0-5cm depth): {ph_value}")
    print(f"Annual Avg Temperature: {temperature}°C")
    print(f"Annual Avg Humidity: {humidity}%")
    print(f"Annual Rainfall: {annual_mm} mm")

    return  ph_value, temperature, humidity, annual_mm

# ============================================================

def get_crops(ph,temp,rainfall,bestList):
    """
    Determines the most suitable crops based on provided land conditions: soil pH, temperature, and rainfall.

    A crop is considered suitable if at least two out of the three criteria (pH, temperature, rainfall) are met.
    Crops already included in the 'bestList' will be excluded from the results.

    Args:
        ph (float): Soil pH value. If unavailable, set to -1.
        temp (float): Annual average temperature (°C).
        rainfall (float): Annual rainfall (in mm/year).
        bestList (list): A list of previously suggested crops. Each element should be a dict with key 'crop_name'.

    Returns:
        list: A list of dictionaries, each representing a suitable crop with the following fields:
            - crop_name (str): Name of the crop.
            - isTemp (bool): Whether temperature is suitable.
            - isPh (bool): Whether pH is suitable.
            - isRainfall (bool): Whether rainfall is suitable.
            - crop_notes (str): Notes indicating which criteria need attention.
            - crop_data (dict): Full crop properties from the original 'crops' dictionary.
    """
    best_crops=[]
    for crop_name,crop_prop in crops.items():
        isPh = False
        isTemp = False
        isRainfall = False
        crop_notes = ""

        if crop_prop['temp_min'] <= temp <= crop_prop['temp_max']:
            isTemp = True
        else:
            crop_notes += "Needs attention to Temperature."


        if ph != -1:
            if crop_prop['ph_min'] <= ph <= crop_prop['ph_max']:
                isPh = True
            else:
                crop_notes += "Needs attention to soil pH."
        else:
            crop_notes += " pH not provided in this land. "

        if crop_prop['rainfall_min'] <= rainfall <= crop_prop['rainfall_max']:
            isRainfall = True
        else:
            crop_notes += f" Needs attention to irrigation. Optimal rainfall: {crop_prop['rainfall_opt_min']} mm/year to {crop_prop['rainfall_opt_max']} mm/year. "

        if (isTemp + isPh + isRainfall) >= 2 and all(crop_name != crop['crop_name'] for crop in bestList):
            best_crops.append({
                "crop_name": crop_name,
                "isTemp": isTemp,
                "isPh": isPh,
                "isRainfall": isRainfall,
                "crop_notes": crop_notes.strip(),
                "crop_data": crop_prop
            })
    return best_crops

# ============================================================

def get_best_crops(ph,temp,rainfall):
    """
       Recommends the best crops for a given land based on optimal environmental conditions.

       This function evaluates each crop's optimal growing requirements—temperature, pH, and rainfall—
       against the given land parameters. If at least two of the three conditions are met,
       the crop is considered suitable and is added to the recommended list.

       Args:
           ph (float): Soil pH value. If unavailable, set to -1.
           temp (float): Annual average temperature (°C).
           rainfall (float): Annual rainfall (in mm/year).

       Returns:
           list: A list of dictionaries representing the best-suited crops. Each dictionary contains:
               - crop_name (str): Name of the crop.
               - isTemp (bool): True if temperature is within optimal range.
               - isPh (bool): True if pH is within optimal range.
               - isRainfall (bool): True if rainfall is within optimal range.
               - crop_notes (str): Warnings or recommendations based on which conditions are not ideal.
               - crop_data (dict): The full crop properties from the original 'crops' dataset.
    """
    best_crops=[]
    for crop_name,crop_prop in crops.items():
        isPh = False
        isTemp = False
        isRainfall = False
        crop_notes = ""

        if crop_prop['temp_opt_min'] <= temp <= crop_prop['temp_opt_max']:
            isTemp = True
        else:
            crop_notes += "Needs attention to Temperature."



        if ph != -1:
            if crop_prop['ph_opt_min'] <= ph <= crop_prop['ph_opt_max']:
                isPh = True
            else:
                crop_notes += "Needs attention to soil pH."
        else:
            crop_notes += " pH not provided in this land. "

        if crop_prop['rainfall_opt_min'] <= rainfall <= crop_prop['rainfall_opt_max']:
            isRainfall = True
        else:
            crop_notes += f" Needs attention to irrigation. Optimal rainfall: {crop_prop['rainfall_opt_min']} mm/year to {crop_prop['rainfall_opt_max']} mm/year. "

        if (isTemp + isPh + isRainfall) >= 2:
            best_crops.append({
                "crop_name": crop_name,
                "isTemp": isTemp,
                "isPh": isPh,
                "isRainfall": isRainfall,
                "crop_notes": crop_notes.strip(),
                "crop_data": crop_prop
            })
    return best_crops

# ============================================================

def image_preprocessing(image):
    # image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    # brightness and contrast enhancements
    brightness = -30
    contrast = 1.5
    image2 = cv2.addWeighted(image, contrast, np.zeros(image.shape, image.dtype), 0, brightness)

    # sharpening kernel (can be removed)
    kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])
    sharpened_image = cv2.filter2D(image2, -1, kernel)

    # remove noise using a Gaussian filter
    filtered_image = cv2.GaussianBlur(sharpened_image, (7, 7), 0)

    # histogram equalization using LAB color space
    # convert RGB image to LAB
    lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)
    l, a, b = cv2.split(lab)
    # apply histogram equalization to the L channel
    l_eq = cv2.equalizeHist(l)
    # merge back with original a and b channels
    lab_eq = cv2.merge((l_eq, a, b))
    # convert LAB back to RGB
    equalized_image = cv2.cvtColor(lab_eq, cv2.COLOR_LAB2RGB)

    return equalized_image

# ===========================================================

def get_moisture_levels(point, start_date='2022-07-01', end_date='2022-07-10'):
    """
    Fetch soil moisture data from NASA SMAP products.

    Args:
        lat (float): Latitude of the point.
        lon (float): Longitude of the point.
        start_date (str): Start date in 'YYYY-MM-DD'.
        end_date (str): End date in 'YYYY-MM-DD'.

    Returns:
        dict: Dictionary with soil moisture data or None if not found.
    """

    # SPL3SMP_E/005 - Soil Moisture (AM)
    spl3 = ee.ImageCollection("NASA/SMAP/SPL3SMP_E/005") \
        .filterDate(start_date, end_date) \
        .filterBounds(point) \
        .select('soil_moisture_am','soil_moisture_pm') \
        .mean()


    try:
        spl3_val = spl3.sample(region=point, scale=9000).first().getInfo()
        result =100* (spl3_val['properties']['soil_moisture_am'] + spl3_val['properties']['soil_moisture_pm'] )/2

    except Exception:
        return None

    return result

def get_phosphorus_levels(point):

    try:
        phosphorus = ee.Image("ISDASOIL/Africa/v1/phosphorus_extractable").sample(point, 30).first().toDictionary()
        phosphorus_val=(phosphorus.getNumber('mean_0_20').getInfo()+phosphorus.getNumber('mean_20_50').getInfo())/2
        return phosphorus_val
    except Exception:
        return None

def get_potassium_levels(point):

    try:
        potassium = ee.Image("ISDASOIL/Africa/v1/potassium_extractable").sample(point, 30).first().toDictionary()
        potassium_val=(potassium.getNumber('mean_0_20').getInfo()+potassium.getNumber('mean_20_50').getInfo())/2
        return potassium_val
    except Exception:
        return None

def get_nitrogen_levels(point):

    try:
        nitrogen = ee.Image("ISDASOIL/Africa/v1/nitrogen_total").sample(point, 30).first().toDictionary()
        nitrogen_val=(nitrogen.getNumber('mean_0_20').getInfo()+nitrogen.getNumber('mean_20_50').getInfo())/2
        return nitrogen_val
    except Exception:
        return None

def get_texture_levels(point):

    try:
        texture = ee.Image("ISDASOIL/Africa/v1/texture_class").sample(point, 30).first().toDictionary()
        texture_val = texture.getNumber('texture_0_20').getInfo()

        if texture_val is not None:
            if 1 <= texture_val <=3:
                return "Clayey"
            elif 4 <= texture_val <=8 or texture_val == 10:
                return "Loamy"
            elif  11<= texture_val <= 12 or texture_val == 9:
                return "Sandy"
        else:
            return None
    except Exception:
        return None

def get_soil_data(lat, lon):
    point = ee.Geometry.Point(lon, lat)

    # Load Phosphorus Image
    phosphorus = get_phosphorus_levels(point)

    # Load Potassium Image
    potassium = get_potassium_levels(point)

    # Load Nitrogen Image
    nitrogen = get_nitrogen_levels(point)

    # Load Soil Texture Image
    texture = get_texture_levels(point)

    # Get Soil Moisture for a specific date
    moisture = get_moisture_levels(point)

    return phosphorus,potassium,nitrogen,texture,moisture


def get_fertilizer_recommendation(Temperature,
                                  Humadity,
                                  Moisture,
                                  Soil_Type,
                                  Nitrogen,
                                  Phosphorus,
                                  Potassium):
    print(f"Inputs:\nTemp={Temperature}, Humidity={Humadity}, Moisture={Moisture}, Soil={Soil_Type}, N={Nitrogen}, P={Phosphorus}, K={Potassium}")
    if (Nitrogen is None or Potassium is None or Soil_Type == "Other"):
        print("Early exit due to invalid input.")
        return None

    try:
        path = os.path.join(BASE_DIR, 'artifacts', 'fertilizer.pkl')
        print(f"Loading model from: {path}")
        with open(path, "rb") as f:
            model = pickle.load(f)
            encode_ferti = pickle.load(f)
            encode_soil = pickle.load(f)

        print("Encoders loaded.")
        soil_type_encoded = encode_soil.transform([Soil_Type])
        print(f"Encoded soil type: {soil_type_encoded}")

        prediction_input = [[Temperature, Humadity, Moisture, soil_type_encoded[0], Nitrogen, Phosphorus, Potassium]]
        fertilizer = model.predict(prediction_input)
        print(f"Raw model prediction: {fertilizer}")

        fertilizer_label = encode_ferti.inverse_transform(fertilizer)
        print(f"Predicted fertilizer label: {fertilizer_label}")
        return fertilizer_label[0]

    except Exception as e:
        print(f"Exception occurred: {e}")
        return None